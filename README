
    Lark
    ----

Lark is an experiment in designing a homoiconic language with a syntax
inspired by SmallTalk. It's very early, so there isn't much to see
yet, but you can play with it.

Lark Syntax
===========

Core syntax
-----------
Internally, Lark has a very simple syntax. It's more complex than
Scheme, but just barely. It has three core expression types:

- Atoms are things like names, numbers and other literals.
- Lists are an ordered set of other expressions.
- Calls are a pair of expressions, the function and the argument.

That's it. Scheme has the first two, and Lark just adds one more.
Every expression in Lark can be desugared to these core elements. The
rest of this section explains the syntactic sugar added on top of
that, but that's handled only by the parser. To the interpreter, the
above is the only syntax.

This *should* mean that it'll be as easy to make powerful macros in
Lark as it is in Scheme.

Prefix functions
----------------
The basic Lark syntax looks much like C. Any series of characters
that starts with a letter (and isn't a keyword, explained below) is
considered a function name. Ex:

    sum (a, abs (b))

If a function call only takes a single argument, the parentheses can
be omitted. Unlike Lisp, parentheses in Lark are only for grouping.
The above can also be written:

    sum (a, abs b)

Dotted functions
----------------
Lark also allows functions to be called using the dot operator. It's
functionally equivalent to a regular function call, but has two minor
differences: the function and argument are swapped, and the precedence
is higher. For example:

    a.b c.d

is desugared to:

    (b(a))(d(c))

Swapping the argument and function may sound a bit arbitrary, but it
allows you to write in an "object.method" style familiar to many OOP
programmers. For example, instead of:

    length list

you can use:

    list.length

Operators
---------
Operators are parsed like SmallTalk. Any sequence of characters
starting with a punctuation one is considered an operator and will
be parsed in infix position. All operators have the same precedence
(no Dear Aunt Sally), and are parsed from left to right. The
expression:

    a + b * c @#%! d
    
is equivalent to:

    @#%!(*(+(a, b), c), d)

Keywords
--------
Lark has keywords that work similar to SmallTalk. A keyword starts
with a letter, has any number of other characters, and ends with a
colon (":"). (A single ":" by itself is also a valid keyword.) The
parser will translate a series of keywords separated by arguments into
a single keyword node. This:

    if: a then: b else: c

is parsed as:

    if:then:else:(a, b, c)

Lists
-----
A list can be created by separating expressions with commas, like so:

    1, 2, 3

Parentheses are not necessary, but are often useful since commas have
low precedence. For example:

    this:              means:

    difference 1, 2     ===>  (difference(1), 2)
    difference (1, 2)   ===>  difference(1, 2)

Precedence
----------
The precedence rules follow SmallTalk. From highest to lowest, it is
prefix functions, operators, keywords, then ",". So, the following:

    if: a < b then: c, d

is parsed as:

    (if:then:(<(a, b), c), d)

That's the basic syntax. The Lark parser reads that and immediately
translates it to the much simpler core syntax.

Running Lark
============

Lark is a Java application stored in a single jar, you can run it by
doing either:

  $ java -jar lark.jar

Or, if you have bash installed, just:

  $ ./lark

This starts up the Lark REPL, like this:

  lark v0.0.0
  -----------
  Type 'q' and press Enter to quit.
  > 

From there you can enter expressions, which the interpreter will
evaluate and print the result.

Built-in functions
==================

So what can you actually do with it? Not much, yet. Only a few
built-in functions are implemented:

' <expr>

    The quote function simply returns its argument in unevaluated
    form. Ex:
    
    > ` print 123
    : print 123
    (note: does not call print function)

do <expr>

    If the expression is anything but a list, it simply evaluates it
    and returns. If it's a list, it evaluates each item in the list,
    in order, and then returns the evaluated value of the last item.
    
    In other words, it's Lark's version of a { } block in C. Ex:
    
    > do (print 1, print 2, print 3)
    1
    2
    3
    : ()

print <expr>

    Simply evaluates the argument and prints it to the console.

<params> => <body>

    Creates an anonymous function (a lambda). <params> should either
    be a single name or a list of parameter names. <body> is an
    expression that forms the body of the function. Ex:
    
    > (a => do (print a, print a)) 123
    123
    123
    : ()

def: <name> is: <expr>

    Binds a value to a variable in the current scope. <name> should
    be a single name. <expr> will be evaluated and the result bound
    to the name. Ex:
    
    > def: a is: 123
    : ()
    > a
    : 123

if: <condition> then: <expr>
if: <condition> then: <expr> else: <else>

    Evaluates the condition. If it evaluates to true, then it
    evaluates and returns <expr>. If it evaluates to false, it will
    either return () or, if an else: clause is given, evaluate and
    return that. Ex:
    
    > if: true then: print 1 else: print 2
    2
    : ()

bool? <expr>
int? <expr>
list? <expr>
name? <expr>
unit? <expr>

    Evaluates <expr> then returns true if it is the given type. Note
    that ().list? returns *true* because unit is the empty list. Ex:
    
    > 123.int?
    : true
    > ('foo).name?
    : true
    > 123.list?
    : false

<int> <expr>

    Evaluates <expr>, expecting it to be a list. Returns the item
    at the <int> position in the list (zero-based). Basically, this
    means an int is a function you can pass a list to to get an item
    from it. Ex:
    
    > 0 (1, 2, 3)
    : 1
    > (4, 5, 6, 7).3
    : 7
    
count <expr>

    Evaluates <expr>, expecting it to be a list. Returns the number of
    items in the list. Ex:
    
    > (1, 2, 3).count
    : 3

That's it so far. Like I said, very early...