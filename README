
    Lark
    ----

Lark is an experiment in designing a homoiconic language with a syntax
inspired by SmallTalk. It's very early, so there isn't much to see
yet, but you can play with it.

Lark Syntax
===========

Core syntax
-----------
Internally, Lark has a very simple syntax. It's more complex than
Scheme, but just barely. It has three core expression types:

- Atoms are things like names, numbers and other literals.
- Lists are an ordered set of other expressions.
- Calls are a pair of expressions, the function and the argument.

That's it. Scheme has the first two, and Lark just adds one more.
Every expression in Lark can be desugared to these core elements. The
rest of this section explains the syntactic sugar added on top of
that, but that's handled only by the parser. To the interpreter, the
above is the only syntax.

This *should* mean that it'll be as easy to make powerful macros in
Lark as it is in Scheme.

Prefix functions
----------------
The basic Lark syntax looks much like C. Any series of characters
that starts with a letter (and isn't a keyword, explained below) is
considered a function name. The following:

    sum (a, abs (b))

will be parsed as:

        ,-----,
        | sum |
        `-----'
        /     \
    ,---,    ,-----,
    | a |    | abs |
    `---'    `-----'
                |
              ,---,
              | b |
              `---'

If a function call only takes a single argument, the parentheses can
be omitted. Unlike Lisp, parentheses in Lark are only for grouping.
The above can also be written:

    sum (a, abs b)

Operators
---------
Operators are parsed like SmallTalk. Any sequence of characters
starting with a punctuation one is considered an operator and will
be parsed in infix position. All operators have the same precedence
(no Dear Aunt Sally), and are parsed from left to right. The
expression:

    a + b * c @#%! d
    
is equivalent to:

    @#%!(*(+(a, b), c), d)

Keywords
--------
Lark has keywords that work similar to SmallTalk. A keyword starts
with a letter, has any number of other characters, and ends with a
colon (":"). (A single ":" by itself is also a valid keyword.) The
parser will translate a series of keywords separated by arguments into
a single keyword node. This:

    if: a then: b else: c

is parsed as:

    if:then:else:(a, b, c)

Lists
-----
A list can be created by separating expressions with commas, like so:

    1, 2, 3

Parentheses are not necessary, but are often useful since commas have
low precedence. For example:

    this:              means:

    difference 1, 2     ===>  (difference(1), 2)
    difference (1, 2)   ===>  difference(1, 2)

Precedence
----------
The precedence rules follow SmallTalk. From highest to lowest, it is
prefix functions, operators, keywords, then ",". So, the following:

    if: a < b then: c, d

is parsed as:

    (if:then:(<(a, b), c), d)

That's the basic syntax. The Lark parser reads that and immediately
translates it to the much simpler core syntax.

Running Lark
============

Lark is a Java application stored in a single jar, you can run it by
doing either:

  $ java -jar lark.jar

Or, if you have bash installed, just:

  $ ./lark

This starts up the Lark REPL, like this:

  lark v0.0.0
  -----------
  Type 'q' and press Enter to quit.
  > 

From there you can enter expressions, which the interpreter will
evaluate and print the result.

Built-in functions
==================

So what can you actually do with it? Not much, yet. Only a few
built-in functions are implemented:

' <expr>

    The quote function simply returns its argument in unevaluated
    form. Ex:
    
    > ` print 123
    : print 123
    (note: does not call print function)

do <expr>

    If the expression is anything but a list, it simply evaluates it
    and returns. If it's a list, it evaluates each item in the list,
    in order, and then returns the evaluated value of the last item.
    
    In other words, it's Lark's version of a { } block in C. Ex:
    
    > do (print 1, print 2, print 3)
    1
    2
    3
    : ()

print <expr>

    Simply evaluates the argument and prints it to the console.

<params> => <body>

    Creates an anonymous function (a lambda). <params> should either
    be a single name or a list of parameter names. <body> is an
    expression that forms the body of the function. Ex:
    
    > (a => do (print a, print a)) 123
    123
    123
    : ()

def: <name> is: <expr>

    Binds a value to a variable in the current scope. <name> should
    be a single name. <expr> will be evaluated and the result bound
    to the name. Ex:
    
    > def: a is: 123
    : ()
    > a
    : 123

That's it so far. Like I said, very early...